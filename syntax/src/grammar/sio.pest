main = _{ SOI ~ statement+ ~ EOI }
statement = {
    skip
    | print
    | value_creation
    | variable_creation
    | var_to_var_binding
    | conditional
    | pattern_match
    | procedure_call
    | async_send
    | selective_receive
    | process_spawn
    | thread
    | module_def
    | named_procedure_def
}
    return_value = {
        expr
        | value
    }
    print = {
        (println_lit | print_lit)
        ~ paren_open ~ string_inst ~ comma ~ print_arg ~ (comma ~ print_arg)* ~ paren_close
        | paren_open ~ string_inst ~ paren_close
    }
        println_lit = { "println" }
        print_lit = { "print" }
        print_arg = {
            procedure_call
            | ident
        }
    skip = { "skip" }
    variable_creation = {
        "let" ~ brace_open
            ~ declaration*
        ~ brace_close ~ "in" ~ brace_open
            ~ statement*
        ~ brace_close
    }
        declaration = {
            data_type_decl
            | named_procedure_def
            | ident_and_type
        }
            ident_and_type = { ident ~ ":" ~ type_decl }
    var_to_var_binding = { ident ~ "=" ~ ident }
    value_creation = { ident ~ "=" ~ (expr|value) }
        value = {
            number_inst
            | boolean_inst
            | char_inst
            | string_inst
            | procedure_def
            | record_inst
            | array_inst
            | list_inst
            | tuple_inst
            | set_inst
            | type_constructor
            | dot_member
            | type_inst
            | paren_open ~ expr ~ paren_close
        }
            dot_member = {
                procedure_call
                | ident ~ dot ~ dot_member
                | ident
            }
            type_constructor = {
                procedure_call
                | type_decl ~ separator ~ type_constructor
            }
            number_inst = { decimal_inst | integer_inst }
                integer_inst = @{ "_"? ~ ASCII_DIGIT+ }
                decimal_inst = @{ "_"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* }
            boolean_inst = { true_lit | false_lit }
                true_lit = { "true" }
                false_lit = { "false" }
            string_inst = @{ "\"" ~ ( "\"\"" | (!"\"" ~ ANY) )* ~ "\"" }
            char_inst = { "'" ~ ASCII_ALPHA ~ "'" }
            record_inst = {
                brace_open
                    ~ ( record_pair ~ ( comma ~ record_pair )*
                        | value ~ (comma ~ value)* )?
                ~ brace_close
            }
                record_pair    = { record_key ~ ":" ~ value }
                record_key= {
                    integer_inst
                    | atom_inst
                    | boolean_inst
                    | string_inst
                    | char_inst
                }
                    atom_inst = { ident }
            array_inst  = {
                array_open
                ~ ( value ~ ( comma ~ value )* )?
                ~ array_close
            }
            list_inst   = {
                bracket_open
                ~ ( value ~ ( comma ~ value )* )?
                ~ bracket_close
            }
            tuple_inst  = {
                paren_open
                ~ ( value ~ ( comma ~ value )* )?
                ~ paren_close
            }
            set_inst = {
                angle_open
                ~ ( value ~ ( comma ~ value )* )?
                ~ angle_close
            }
            type_inst = {
                data_type_name
                ~ paren_open
                ~ ( value ~ ( comma ~ value )* )
                ~ paren_close
                | data_type_name
            }

    conditional = {
        "if" ~ procedure_call ~ brace_open
            ~ statement* ~ return_value?
        ~ brace_close ~ "else" ~ brace_open
            ~ statement* ~ return_value?
        ~ brace_close
    }
    procedure_call = {
        ident ~ dot ~ procedure_call
        | list_append
        | ident ~ paren_open ~ args? ~ paren_close
    }
        list_append = { ident ~ pipe ~ ident }
        list_head_tail = { ident ~ pipe ~ ident }
        op_unary_minus =  { "-" }
        op_unary_not   =  { "!" }
        op_unary       = _{
            op_unary_minus
            | op_unary_not
        }
        op_plus          =  { "+" }
        op_minus         =  { "-" }
        op_times         =  { "*" }
        op_divide        =  { "/" }
        op_and           =  { "&&" }
        op_or            =  { "||" }
        op_greater       =  { ">" }
        op_greater_equal =  { ">=" }
        op_lower         =  { "<" }
        op_lower_equal   =  { "<=" }
        op_equal         =  { "==" }
        op_infix         = _{
            op_plus
            | op_minus
            | op_times
            | op_divide
            | op_and
            | op_or
            | op_greater_equal
            | op_greater
            | op_lower_equal
            | op_lower
            | op_equal
        }
        paren_open       = { "(" }
        paren_close      = { ")" }
        brace_open       = { "{" }
        brace_close      = { "}" }
        bracket_open     = { "[" }
        bracket_close    = { "]" }
        angle_open       = { "<" }
        angle_close      = { ">" }
        array_open       = { "[|" }
        array_close      = { "|]" }
        dot              = { "." }
        comma            = { "," }
        pipe             = { "|" }
        args  = _{ expr ~ (comma ~ expr)* }
        term = { op_unary* ~ value ~ (dot ~ procedure_call)* }
        expr = { term ~ (op_infix ~ term)* }
    pattern_match = {
        "match" ~ value
        ~ brace_open
        ~ match_body+
        ~ brace_close
    }
        match_body = {
            list_match
            | array_match
            | boolean_match
            | char_match
            | string_match
        }
            list_match = {
                pipe
                ~ bracket_open
                  ~ ident
                  ~ pipe
                  ~ ident
                  ~ pipe
                  ~ ident
                ~ bracket_close ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
                | pipe
                ~ bracket_open
                  ~ ident
                  ~ pipe
                  ~ ident
                ~ bracket_close  ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
                | pipe
                ~ bracket_open
                ~ bracket_close ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
            }
            array_match = {
                pipe
                ~ array_open
                  ~ ident
                  ~ pipe
                  ~ ident
                ~ array_close ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
                | pipe
                ~ array_open
                  ~ ident
                ~ array_close ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
                | pipe
                ~ array_open
                ~ array_close ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
            }
            boolean_match = {
                pipe
                ~ true_lit ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
                | pipe
                ~ false_lit ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
            }
            char_match = {
                pipe
                ~ char_inst ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
                | pipe
                ~ "_" ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
            }
            string_match = {
                pipe
                ~ string_inst ~ "=>" ~ brace_open
                  ~ statement* ~ return_value?
                ~ brace_close
            }
    module_def = {
        "mod" ~ hbfi ~ brace_open
            ~ module_declaration*
        ~ brace_close ~ "in" ~ brace_open
            ~ named_procedure_def+
        ~ brace_close
    }
        module_name = @{ ident }
        hbfi = {
            application ~ "/" ~ module ~ public_key
        }
            public_key = @{ "_" | ASCII_ALPHANUMERIC {64} }
            application = @{ ASCII_ALPHA_LOWER ~ ( ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")*  }
            module = @{ ASCII_ALPHA_LOWER ~ ( ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }
        module_declaration = {
            import_statement
            | named_procedure_def
            | module_data_type_export
            | ident_and_type
        }
            import_statement = {
                "use"
                ~ import_from_public_key+
            }
            import_from_public_key = {
                public_key
                ~ separator
                ~ brace_open
                ~ import_from_application+
                ~ brace_close
            }
            import_from_application = {
                application
                ~ separator
                ~ brace_open
                ~ import_from_module+
                ~ brace_close
            }
            import_from_module = {
                module ~ separator ~ brace_open
                ~ (module_import_function_name | module_import_type_name)
                ~ (comma ~ (module_import_function_name | module_import_type_name))*
                ~ brace_close
            }
            module_import_function_name = @{ident}
            module_import_type_name = @{type_decl}
            module_data_type_export = { (stability? ~ data_type_decl) }
    async_send     =  { ident ~ "!" ~ value }
    selective_receive = {
        "receive"
        ~ (deterministic_receive | nondeterministic_receive)
        ~ brace_open
        ~ match_body+
        ~ brace_close
    }
        deterministic_receive = {
            ident
        }
        nondeterministic_receive = {
            "all"
        }
    process_spawn = {
        "spawn"
        ~ brace_open
        ~ statement+
        ~ brace_close
    }
    thread = {
        "thread"
        ~ brace_open
        ~ statement+
        ~ brace_close
    }

named_procedure_def = { named_procedure_header ~ procedure_def }
    named_procedure_header = {
        stability?
        ~ procedure_name
        ~ separator
    }
    stability = @{ summon | sketch | stable | sunset | seeyou }
        summon = { "summon" }
        sketch = { "sketch" }
        stable = { "stable" }
        sunset = { "sunset" }
        seeyou = { "seeyou" }
    procedure_name = { lazy? ~ (generic_procedure | concrete_procedure) }
    generic_procedure = {
        ident
        ~ angle_open
        ~ generic_type_label ~ (comma ~ generic_type_label)*
        ~ angle_close
    }
    lazy = {
        "lazy"
    }
    concrete_procedure = {
        ident
    }
    procedure_header = {
        paren_open
        ~ procedure_parameters?
        ~ paren_close
        ~ procedure_return_type?
    }
        procedure_parameters = {
            procedure_parameter
            ~ (comma ~ procedure_parameter)*
        }
            procedure_parameter = {
                ident ~ ":" ~ higher_order_procedure_header
                | ident_and_type
            }
    higher_order_procedure_header = {
        paren_open
        ~ higher_order_procedure_parameters?
        ~ paren_close
        ~ procedure_return_type?
    }
        higher_order_procedure_parameters = {
            higher_order_procedure_parameter
            ~ (comma ~ higher_order_procedure_parameter)*
        }
            higher_order_procedure_parameter = {
                type_decl
                | ident ~ ":" ~ higher_order_procedure_header
            }
        procedure_return_type = { "->" ~ ( higher_order_procedure_header | type_decl ) }
    procedure_def = {
        procedure_header
        ~ brace_open
        ~ procedure_body
        ~ brace_close
        ~ procedure_in?
        ~ procedure_where?
    }
        procedure_body = {
            statement* ~ return_value?
        }
        in_lit = @{ "in" }
        where_lit = @{ "where" }
        procedure_in = {
            in_lit
            ~ brace_open
            ~ statement* ~ return_value?
            ~ brace_close
        }
        procedure_where = {
            where_lit
            ~ brace_open
            ~ statement* ~ return_value?
            ~ brace_close
        }

ident = @{ ASCII_ALPHA_LOWER ~ ( ASCII_ALPHA_LOWER | ASCII_DIGIT | "_")* }

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/"}

separator = @{ "::" }

/* Type Declaration */
data_type_decl = {
    "data"
    ~ type_decl
    ~ "="
    | (pipe ~ variant_constructor) {2,}
    | variant_constructor
}
type_decl = {
    generic_data_type_decl
    | no_generic_data_type_decl
    | collection_decl
}
generic_data_type_decl = {
    data_type_name
    ~ angle_open
    ~ type_decl ~ (comma ~ type_decl)*
    ~ angle_close
}
no_generic_data_type_decl = {
    data_type_name
}
variant_constructor = {
    stability?
    ~ product_variant_constructor
    | empty_variant_constructor
}
data_type_name = @{
    ASCII_ALPHA_UPPER
    ~ (ASCII_ALPHA_LOWER
      | ASCII_DIGIT
      | ASCII_ALPHA_UPPER)*
}
generic_type_label = { generic_type_name }
generic_type_name = @{
    ASCII_ALPHA_UPPER
    ~ (ASCII_ALPHA_LOWER
      | ASCII_DIGIT
      | ASCII_ALPHA_UPPER)*
}
product_variant_constructor = {
    variant_constructor_name
    ~ paren_open
    ~ type_decl ~ (comma ~ type_decl)*
    ~ paren_close
}
empty_variant_constructor = {
    variant_constructor_name
}
variant_constructor_name = @{
    ASCII_ALPHA_UPPER
    ~ (ASCII_ALPHA_LOWER
      | ASCII_DIGIT
      | ASCII_ALPHA_UPPER)*
}
collection_decl = {
    record_type_decl
    | list_type_decl
    | array_type_decl
    | tuple_type_decl
    | set_type_decl
}
record_type_decl = {
    brace_open
    ~ (record_pair_decl ~ (comma ~ record_pair_decl)*)
    ~ brace_close
}
    record_pair_decl = { key_type_decl ~ ":" ~ (higher_order_procedure_header | type_decl) }
        key_type_decl  = {
            atom_inst
            | i64_type
            | bool_type
            | string_type
            | char_type
        }
list_type_decl   = {
    bracket_open
    ~ type_decl
    ~ bracket_close
}
array_type_decl  = {
    array_open
    ~ array_length ~ ";"
    ~ type_decl
    ~ array_close
}
    array_length = { integer_inst }
tuple_type_decl  = {
    paren_open
    ~ (type_decl ~ (comma ~ type_decl)*)?
    ~ paren_close
}
set_type_decl = {
    angle_open
    ~ type_decl
    ~ angle_close
}

bool_type   = { "Bool" }
i64_type    = { "I64" }
f64_type    = { "F64" }
string_type = { "String" }
char_type   = { "Char" }
unit_type   = { "Unit" }

